#数据结构 
# [45]     线索二叉树的概念
### 1. 普通二叉树的遍历
对二叉树进行遍历，原本的非线性关系，经过遍历之后，得到了线性关系。
例如，如下的二叉树经过中序遍历后，形成了`DGBEAFC`的线性关系。
需要明确的是，二叉树的本身是一个节点对应唯一前驱和多个后继，基于遍历序列，每个节点只有唯一一个前驱和后继。

【问题】能否从一个指定结点，例如给出指向G的指针`ptr`开始中序遍历？ 
答案是不可以的。因为节点的指向是单向，节点的指向是指向它的孩子，而并非指向双亲。对于树的遍历，只能从根节点开始。
假如，遍历序列以线性表的形式存储，那么对于任一个给定的元素，都可以找到该数据结构的其他要素。
![[img/Ch05 树/39 二叉线索树.png]]
【问题】
① 如何找到指定结点p 在q中序遍历序列中的前驱？
② 如何找到p的中序后继？
**思路**：
从根节点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针 pre 记录上一个被访问的结点。
①当`q == p`时，pre为前驱；②当`pre == p`时，q为后继。
**缺点**：找前驱、后继很不方便，操作必须从根开始。

### 2. 中序线索二叉树
原普通二叉树存在很多空链域，这些空链域可以用来指向他们的前驱和后继。
![[img/Ch05 树/40 原普通二叉树.png]]
利用叶子节点的空链域，分别指向他们的前驱和后继。这个过程叫做二叉树的线索化。
这个时候，通过某个节点找到其前驱和后继只需要通过**前驱线索**和**后继线索**即可。
![[img/Ch05 树/41 线索二叉树.png]]
## 3. 线索二叉树的存储结构
```c
// 二叉树的结点（链式存储）
typedef struct BiTNode {
    ElemType data;
    BiNode *lchild, *rchild;
} BiTNode, *BiTree;

// 线索二叉树的结点
typedef struct ThreadNode {
    ElemType data;
    ThreadNode *lchild, *rchild;
    int ltag, rtag;        // 左、右线索标志
} ThreadNode, *ThreadTree;
```
当`tag == 0`，表示指针指向孩子；当`tag == 1`，表示指针指向线索。
二叉树可以叫做二叉链表，线索二叉树可以叫做线索链表。
原二叉树，可以直接转化成以下的形式：
![[img/Ch05 树/42 线索二叉树的存储.png]]
同理，中序遍历二叉树序列的线索化，可以推广到前序线索二叉树、后序线索二叉树。
![[img/Ch05 树/43 先序遍历二叉树线索化.png]]

![[img/Ch05 树/44 后序遍历二叉树线索化.png]]
- **中序线索二叉树** —— 线索指向**中序前驱**、**中序后继**；
- **先序线索二叉树** —— 线索指向**先序前驱**、**先序后继**；
- **后序线索二叉树** —— 线索指向**后序前驱**、**后序后继**。

# [46]     二叉树的线索化
## 1. 中序线索化
回顾对普通二叉树进行某一个结点求其前驱的过程：
![[img/Ch05 树/45 找中序前驱一般的方法.png]]
```c
// 中序遍历寻找前驱
void FindPre(BiTree T) {
    if (T != NULL){
        InOrder(T->lchild);    // 递归遍历左子树
        visit(T);            // 访问根节点
        InOrder(T->rchild);    // 递归遍历右子树
    }
}

// 访问结点q
void visit(BiTree T) {
    if (q == p) {            // 如果临时变量刚好访问到p
        final = pre;         // 找到p的前驱
    } else {
        pre = q;            // pre 指向当地访问的结点
    }
}

// 辅助全局变量，用于查找结点p的前驱
BiTNode *p;                    // p指向目标节点；
BiTNode *pre;                // pre指向当前节点的前驱；
BiTNode *final = NULL;        // final用于记录最终结果；
```

![[img/Ch05 树/41 线索二叉树.png]]
如果使用线索二叉树：
```c
typedef struct ThreadNode {
    ElemType data;
    ThreadNode *lchild, *rchild;
    int ltag, rtag;        // 左、右线索标志
} ThreadNode, *ThreadTree;

// 中序遍历二叉树，一边遍历一边线索化
void InThread(ThreadTree T) {
    if (T != NULL) {
        InTread(T->lchild);        // 中序遍历左子树
        visit(T);                // 访问根节点
        InTread(T->rchild);        // 中序遍历右子树
    }
}

// 线索化
void visit(ThreadNode *q) {
    // 左子树是空
    if (q->lchild == NULL) {
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = q;    // 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;
```
最后要继续检查pre的rchild是否是NULL，如果是的话，令`rtag` = 1.
中序线索化的过程，调用`InThread`函数：
```c
// 全局变量 pre， 指向当前访问结点的前驱
ThreadNode *pre = NULL;

// 中序线索化二叉树
void CreateInThread(ThreadNode T) 
{
    pre = NULL;                // pre初始化为NULL
    if (T != NULL) {        // 非空二叉树才能线索化
        InThread(T);        // 中序线索化二叉树
        if (pre->rchild == NULL){
            pre->rtag = 1;    // 处理遍历的最后一个结点
        }
    }
}

// 调用函数： CreateInThread --> InThread --> visit
```

中序线索化其实就是对树的中序遍历，只不过在visit当中，添加了线索化过程。但是对于最后一个右孩子的结点后驱进行特殊处理。

![[img/Ch05 树/42 线索二叉树的存储.png]]

还可以使用递归调用直接实现线索化的过程：
```c
// 中序线索化，这里的pre是一个引用类型
void InThread(ThreadTree p, ThreadTree &pre)
{    
    if(p != NULL) {    
        InThread(p->lchild, pre);    // 递归，线索化左子树
        // 处理根节点
        if (p->lchild == NULL) {    // 左子树为空，建立前驱线索
            p->lchild = pre;        
            p->ltag = 1;
        }
        if (pre != NULL && pre->rchild == NULL) {
            // 右子树为空，建立前驱结点的后继线索
            pre->rchild = p;        
            pre->rtag = 1;
        }
        InThread(p->rchild, pre);    // 递归，线索化右子树
    }
}
```
【思考】为什么处理遍历最后一个结点时，不判断`rchild`是否为`NULL`？
因为中序遍历的最后一个结点右孩子指针必为空。

## 2. 先序线索化
![[img/Ch05 树/43 先序遍历二叉树线索化.png]]
```c
// 先序遍历二叉树，一边遍历一边线索化
void PreThread(ThreadTree T)
{
    if (T != NULL) {
        visit(T);            // 先处理根节点
        if (T-> ltag == 0)    // lchild 不是前驱线索
        {
            PreThread(T->lchild);
        }
        PreThread(T->rchild);
    }
}

// 线索化
void visit(ThreadNode *q) 
{
    // 左子树是空，建立前驱线索
    if (q->lchild == NULL) {
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = q;    // 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;

void PreThread(ThreadTree T)
{
    if (T != NULL) {
        visit(T);            // 先处理根节点
        if (T-> ltag == 0)    // lchild 不是前驱线索
        {
            PreThread(T->lchild);
        }
        PreThread(T->rchild);
    }
}

// 先序线索化二叉树
void CreatePreThread(ThreadNode T) 
{
    pre = NULL;                // pre初始化为NULL
    if (T != NULL) {        // 非空二叉树才能线索化
        PreThread(T);        // 中序线索化二叉树
        if (pre->rchild == NULL){
            pre->rtag = 1;    // 处理遍历的最后一个结点
        }
    }
}

```
在先序二叉树线索化过程中，如果不采取`if (T-> ltag == 0)`判定的话，对其指向结点访问，有可能访问前驱结点，造成死循环问题。

## 3. 后序线索化
![[img/Ch05 树/44 后序遍历二叉树线索化.png]]
```c
// 后序遍历二叉树，一边遍历一边线索化
void PostThread(ThreadTree T) 
{
    if (T != NULL) {
        PostThread(T->lchild);        // 后序遍历左子树
        PostThread(T->rchild);        // 后序遍历右子树
        visit(T);                    // 访问根节点
    }
}

// 线索化
void visit(ThreadNode *q) 
{
    // 左子树是空，建立前驱线索
    if (q->lchild == NULL) {
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = q;    // 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;

// 后序线索化二叉树T
void CreatePostThread(ThreadNode T) 
{
    pre = NULL;                // pre初始化为NULL
    if (T != NULL) {        // 非空二叉树才能线索化
        PostThread(T);        // 中序线索化二叉树
        if (pre->rchild == NULL){
            pre->rtag = 1;    // 处理遍历的最后一个结点
        }
    }
}
```
后序线索化并不会出现类似先序线索化的“死循环”问题。

# [47] 在线索二叉树中找前驱后继
二叉树的线索化，最终目的时为了找到遍历序列的前驱和后继，以下讲着重探讨在不同类型的线索二叉树下，怎么找前驱和后继。

## 1. 中序线索二叉树找中序后继
【问题】中序线索二叉树，如何找到指定结点 `*p` 的中序后继 `next`？
① 若 `p->rtag == 1`，则`next = p->rchild`（中序遍历：左-->根--> 右，如果`rtag`值表示1，即表示该叶子结点有后继线索，直接赋值即可）;
② 若 `p->rtag == 0`，表示这个结点一定是有右孩子的，`next = p的右子树中最左下的结点`。
![[img/Ch05 树/46 中序线索二叉树后继.png]]
代码实现：
```c
// 函数调用：InOrder --> NextNode --> FirstNode
// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)
void InOrder(ThreadNode *T)
{
    for(ThreadNode *p = FirstNode(T); p != NULL; 
        p = NextNode(p)){
        visit(p);
    }
}

// 中序线索二叉树中找到结点p的后继结点
ThreadNode *NextNode(ThreadNode *p)
{
    // 右子树中最左下结点
    if (p->rtag == 0){
        return FirstNode(p->rchild);
    } else {
        // rtag == 1 直接返回后继线索。
        return p->rchild;
    }
}

// 找到以P为根的子树，第一个被中序遍历的结点
ThreadNode *FirstNode(ThreadNode *p)
{
    // 循环找到最左下结点(不一定是叶结点)
    while (p->ltag == 0){
        p = p->lchild;
    }
    return p;
}
```

## 2. 中序线索二叉树找中序前驱
【问题】中序线索二叉树，如何找到指定结点 `*p` 的中序前驱 `pre`？
① 若 `p->ltag == 1`，则`pre = p->lchild`（中序遍历：左-->根--> 右，如果`ltag`值表示1，即表示该叶子结点有前驱线索，直接赋值即可）;
② 若 `p->ltag == 0`，表示这个结点一定是有左孩子的，`next = p的左子树中最右下的结点`。
![[img/Ch05 树/47 中序线索二叉树前驱.png]]
```c
// 对中序线索二叉树进行逆向中序遍历(利用线索实现的非递归算法)
void ReverseInOrder(ThreadNode *T)
{
    for(ThreadNode *p = LastNode(T); p != NULL; 
        p = PreNode(p)){
        visit(p);
    }
}

// 中序线索二叉树中找到结点p的前驱结点
ThreadNode *PreNode(ThreadNode *p)
{
    // 左子树中最右下结点
    if (p->rtag == 0){
        return LastNode(p->lchild);
    } else {
        // ltag == 1 直接返回后继线索。
        return p->lchild;
    }
}

// 找到以P为根的子树，最后一个被中序遍历的结点
ThreadNode *LastNode(ThreadNode *p)
{
    // 循环找到最右下结点(不一定是叶结点)
    while (p->rtag == 0){
        p = p->rchild;
    }
    return p;
}
```

## 3. 先序线索二叉树找先序后继
【问题】先序线索二叉树（根节点--> 左孩子 --> 右孩子），如何找到指定结点 `*p` 的先序后继 `next`？
① 若 `p->rtag == 1`，同理，则`next = p->rchild`;
② 若 `p->rtag == 0`，表示这个结点一定是有右孩子的。
这个时候，需要对这个结点的左孩子情况进行讨论。
- 如果有左孩子，那么先序后继为左孩子；
- 如果有没有左孩子，那么先序后继为右孩子。
![[img/Ch05 树/48 先序线索二叉树后继.png]]
```c
// 找先序线索二叉树p的后继
ThreadNode *FindNext(ThreadNode *p){
    if (p->rtag == 1){
        return p->rchild;
    } else if (p->ltag == 0){
        return p->lchild;
    } else {
        return p->rchild;
    }
}
```

## 4. 先序线索二叉树找先序前驱
先序遍历：某一个结点的前驱左右子树只可能是它的后继，均不可能是它的前驱，所以，可以使用最原始的方式从根节点依次遍历。
或者采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。

如果采取后者，就需要对具体情况进行分类**逐个讨论**了：
![[img/Ch05 树/49 先序线索二叉树前驱.png]]

- 情形1：如果能找到p的父节点，且p是左孩子。父结点是前驱。
- 情形2：如果能找到p的父节点，且p是右孩子，其左兄弟为空。父结点是前驱。
- 情形3：如果能找到p的父节点，且p是右孩子且左孩子不为空。**左兄弟子树最后一个被先序遍历的结点**是前驱。
- 情形4：没有父节点。没有前驱。

## 5. 后序线索二叉树找后序前驱
【问题】后序线索二叉树，如何找到指定结点 `*p` 的中序前驱 `pre`？
① 若 `p->ltag == 1`，则`pre = p->lchild`（同理）;
② 若 `p->ltag == 0`，表示这个结点一定是有左孩子的。
这个时候，需要对这个结点的左孩子情况进行讨论。
- 如果有右孩子，那么后序前驱为右孩子；
- 如果没有右孩子，那么后序前驱为左孩子；
![[img/Ch05 树/50 后序线索二叉树前驱.png]]
```c
// 找后序线索二叉树p的前驱
ThreadNode *FindPre(ThreadNode *p){
    if (p->rtag == 1){
        return p->lchild;
    } else if (p->rtag == 0){
        return p->rchild;
    } else {
        return p->lchild;
    }
}
```

## 6. 后序线索二叉树找后序后继
后序遍历：某一个结点的后驱左右子树只可能是它的前驱，均不可能是它的后继，所以，可以使用最原始的方式从根节点依次遍历。
或者采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。

如果采取后者，同样需要对具体情况进行分类**逐个讨论**了：
![[img/Ch05 树/51 后序线索二叉树后继.png]]

- 情形1：如果能找到p的父节点，且p是右孩子。父结点是后继。
- 情形2：如果能找到p的父节点，且p是左孩子，其右兄弟为空。父结点是后继。
- 情形3：如果能找到p的父节点，且p是左孩子且右孩子不为空。**右兄弟子树第一个被后序遍历的结点是后继**是后继。
- 情形4：没有父节点。没有后继。
