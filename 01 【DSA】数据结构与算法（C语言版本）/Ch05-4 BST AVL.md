#数据结构 
# [48]     树的存储结构
## 1. 双亲表示法
每个结点中保存指向双亲的“指针”。

![](img/Ch05%20树/02%20子树.jpg)
```c
# define MAX_TREE_SIZE 100      // 树中最多的结点
typedef struct {        // 树的结点定义
    ElemType data;      // 数据元素
    int parent;         // 双亲位置域
} PTNode;

typedef struct {                // 树的类型定义
    PTNode node[MAX_TREE_SIZE]; // 双亲表示
    int n;                      // 结点树
} PTree;
```

| 数组下标 | data  | parent |
|:--------:|:----:|:------:|
|    0     |  A   |   -1   |
|    1     |  B   |   0    |
|    2     |  C   |   0    |
|    3     |  D   |   0    |
|    4     |  E   |   1    |
|    5     |  F   |   1    |
|    6     |  G   |   2    |
|    7     |  H   |   3    |
|    8     |  I   |   3    |
|    9     |  J   |   3    |
|    10    |  K   |   4    |
|    11    | ...  |  ...   |

其中，根节点固定存储在0，-1表示没有双亲。

问题来了，**如何让用双亲表示法实现增删查操作**？
新增数据元素时候，无需按逻辑上的次序存储，直接再尾部新增即可。例如新增M、L结点，只需要在尾部新增即可。

|  数组下标  |  data  |  parent  |
|:----------:|:------:|:--------:|
| .......... | ...... | ........ |
|     11     |   M    |    7     |
|     12     |   L    |    4     |

删除数据元素，如果是叶子结点的话，可以直接删除元素，也可以只让data值删除。
如果不是叶子结点，删除的时候，就需要找到它的所有孩子结点并且全部删除。但是，查找指定结点的孩子只能从头遍历。

## 2. 孩子表示法
采用顺序+链式存储，顺序存储各个节点，每个结点中保存孩子链表头指针。
```c
struct CTNode {
    int child;              // 孩子结点在数组中的位置
    struct CTNode *next;    // 下一个孩子
};

typedef struct {
    ElemType data;
    struct CTNode *firstChild;  // 第一个孩子
} CTBox;

typedef struct {
    CTBox nodes[MAX_TREE_SIZE];
    int n, r;               // 结点数和根的位置
}
```

![[img/Ch05 树/52 孩子表示法存储树.png]]

## 3. 孩子兄弟表示法
纯粹使用链表的方式存储：
```c
// 树的存储 -- 孩子兄弟表示法
typeddef struct CSNode {
    ElemType data;                           // 数据域
    struct CSNode *firstchild, *nextSibling; // 第一个孩子和右兄弟指针
} CSNode, *CSTree;
```

这样的表示方法和二叉树形式同构，可以看作是左指针和右指针表示法。
![[img/Ch05 树/53 树转化成二叉树.png]]
如图，树转化的二叉树中，某个结点的左右两叉完全属于不同层次。
左叉（蓝色线）为孩子，右叉（黄色线）为兄弟，沿着黄色线一直追溯即可把所有的同层次的结点全找到。相对应的，二叉树也可以复原成原来树的逻辑结构。

## 4. 森林与二叉树转化
把森林中所有的根节点全都视为兄弟。
![[img/Ch05 树/54 森林转化成二叉树.png]]
相对应的，二叉树也可以复原成原来森林的逻辑结构。

# [49]     树和森林的遍历
## 1. 树的遍历
树的遍历有以下几种方式：先根遍历、后根遍历、层次遍历。
1. **先根遍历**。
若树非空，先访问根结点，再依次对每棵子树进行先根遍历。
```c
// 树的先根遍历
void PreOrder (TreeNode *R)
{
    if (R != NULL) {
        visit(R);       // 访问根节点
        while( R 还有下一个子树T ){
            PreOrder(T); // 先根遍历下一个子树
        }
    }
}
```
树的**先根遍历序列**与这棵树转化形成的相应二叉树的**先序序列**相同。
如下这个树的先根遍历序列是：`ABEKFCGDHIJ`。

![[img/Ch05 树/53 树转化成二叉树.png]]

2. **后根遍历**。
若树非空，先依次访问每棵子树进行后根遍历，再访问根结点。
```c
// 树的先根遍历
void PostOrder (TreeNode *R)
{
    if (R != NULL) {
        while( R 还有下一个子树T ){
            PostOrder(T); // 后根遍历下一个子树
        }
        visit(R);         // 访问根节点
    }
}
```
树的**后根遍历序列**与这棵树转化形成的相应二叉树的**中序序列**相同。
如下这个数的先根遍历序列是：`KEFBCGDHIJA`。

3. **层次遍历**。
使用队列实现：
（1） 若树非空，则根结点入队；
（2） 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；
（3） 重复（2）直到队列为空。

> 对树的层次遍历可以称作是对树的**广度优先遍历**(Breadth_First_Search)，对数的先根遍历、后跟遍历是对树的**深度优先遍历**(Depth_First_Search)。

## 2. 森林的遍历
1. 先序遍历森林：
若森林为非空，则按如下规则进行遍历：
（1）访问森林中第一棵树的根结点。
（2）先序遍历第一棵树中根结点的子树森林。
（3）先序遍历除去第一棵树之后剩余的树构成的森林。
![[img/Ch05 树/54 森林转化成二叉树.png]]
对森林的先序遍历，效果等同于依次对各个树进行先根遍历，实质上，等同于依次对**二叉树的先序遍历**。
上图中森林的先序遍历是`BEKFCGDHMIJ`。

2. 中序遍历森林：
若森林为非空，则按如下规则进行遍历：
（1）中序遍历森林中第一棵树的根结点的子树森林。
（2）访问第一棵树的根结点。
（3）中序遍历除去第一棵树之后剩余的树构成的森林。

对森林的先序遍历，效果等同于依次对各个树进行后根遍历，实质上，等同于依次对**二叉树的中序遍历**。上图中森林的中序遍历是`KEFBGCMHIJD`。

| 树  | 森林 | 二叉树 |
| --- | ---- | ------ |
| 先根遍历   | 先序遍历  |  先序遍历   |
| 后根遍历   | 中序遍历  |  中序遍历   |

# [50]     二叉排序树
二叉排序树，又称二叉查找树（BST，Binary Search Tree），符合这样的特点：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
1. 左子树上所有结点的关键字均小于根结点的关键字；
2. 右子树上所有结点的关键字均大于根结点的关键字。
3. 左子树和右子树又各是一棵二叉排序树。
![[img/Ch05 树/55 BST.png]]
对二叉排序树，进行中序排列，可以得到一个递增的有序序列。
## 1. BST 的查找 
查找思路分析：
1. 若树非空，目标值与根结点的值比较；
2. 若相等，则查找成功；
3. 若小于根结点，则在左子树上查找，否则在右子树上查找，重复该步骤。
4. 查找成功，返回结点指针；查找失败返回NULL。

```c
// BST结点定义
typedef struct BSTNode {
    int key;
    struct BSTNode *lchild, *rchild;
} BSTNode, *BSTree;

// 在BST中查找值为key的结点
BSTNode *BSTSearch(BSTree T, int key)
{   
    // 树若是空的或者等于根节点的值，就可以直接结束循环
    while (T != NULL && key != T->key) {
        // key小于根结点的值，查找其左子树
        if (key < T->key) {
            // T 往下深一层，执行下一次循环
            T = T-> lchild;
        // key大于根结点的值，查找其右子树
        } else {
            // T 往下深一层，执行下一次循环
            T = T->rchild; 
        }
    }
    return T;
}
```
以上程序属于非递归（循环）的实现，如果使用递归同样可以实现：
```c
// 递归实现二叉排序树查找
BSTNode *BSTSearch(BSTree T, int key)
{
    if (T == NULL) {
        return NULL;                        // 查找失败
    }
    if (key == T->key) {
        return T;                           // 查找成功
    }
    else if (key < T->key){
        return BSTSearch(T->lchild, key);   // 在左子树中找
    }
    else if (key > T->key){
        return BSTSearch(T->rchild, key);   // 在右子树中找
    }
}
```
综合比较，循环实现的最坏空间复杂度是$O(1)$，递归实现的最坏空间复杂度是$O(h)$。

## 2. BST 的结点插入
若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。
```c
// 在二叉排序树插入关键字为k的新结点(递归实现)
int BSTInsert(BSTree &T, int k)
{
    // 原树为空，插入新结点
    if (T == NULL) {
        T = (BSTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild = T->rchild = NULL;
        return 1;
    }
    // 已经存在相同关键字的结点，插入失败
    else if (K == T->key) {
        return 0;
    } 
    // 插入到T的左子树
    else if (K < T->key) {
        return BSTInsert(T->lchild, k);
    } 
    // 插入到T的右子树
    else {
        return BSTInsert(T->rchild, k);
    }
}
```
对于二叉排序树的插入而言，新插入的结点一定是叶子，并且使用递归，最坏空间复杂度为$O(h)$。

## 3. BST 的构造
【例题】依照序列array[n]建立BST。
```c
// 按照array[]中关键词序列依次建立二叉排序树
void CreateBST(BSTree &T, int array[], int n)
{
    T = NULL;           // 二叉树初始化为空树
    int i = 0;
    while (i < n)
    {
        // 依次调用BST插入函数，插入数组每个元素
        BSTInsert(T, str[i]);
        i++;
    }
}
```

## 4. BST 的数据删除 
先搜索找到目标结点：
1. 若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。
2. 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。
3. 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。
- z的后继：z的右子树中最左下结点（该节点一定没有左子树）。
- z的前驱：z的左子树中最右下结点（该节点一定没有右子树）。

## 5. BST 的效率分析 
查找长度——在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度。
查找成功的平均查找长度 ASL（Average Search Length）：若树高h，找到最下层的一个结点需要对比 h 次。

![[img/Ch05 树/56 BST查找成功ASL.png]]

- **最好情况**：n个结点的二叉树最小高度为$⌊log_2{n}⌋+ 1$。平均查找长度= $O(log_2{n})$。
- **最好情况**：每一个结点只有一个分支，树高度为h，结点树 n = h，平均查找长度= $O(n)$。

![[img/Ch05 树/57 BST查找失败ASL.png]]
查找失败的的平均查找长度（ASL）也可以进行计算。

# [51]     平衡二叉树
平衡二叉树（Balanced Binary Tree），简称平衡树（AVL树）—— 树上任一结点的左子树和右子树的高度之差不超过1。
`结点的平衡因子 = 左子树高 - 右子树高`
G. M. Adelson-Velsky和E. M. Landis 于1962年发明。
![[img/Ch05 树/58 AVL.png]]
平衡二叉树结点的平衡因子的值只可能是−1、0或1。
只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树。
```c
// 平衡二叉树结点
typedef struct AVLNode
{
    int key;            // 数据域
    int balance;        // 平衡因子
    struct AVLNode *lchild, *rchild;
} AVLNode, *AVLTree;
```
## 1. AVL的插入
![[img/Ch05 树/59 AVL 插入.png]]
在二叉排序树中插入新结点后，查找路径上的所有结点都有可能受到影响，从插入点往回
找到第一个不平衡结点，调整以该结点为根的子树。
上图中，以70为根节点的子树，即是“最小不平衡子树”。
![[img/Ch05 树/60 调整不平衡子树.png]]

分析得出，调整最小不平衡子树，有以下四种情况：
- 在A的**左孩子**的**左子树**中插入导致不平衡（LL）；
- 在A的**右孩子**的**右子树**中插入导致不平衡（RR）；
- 在A的**左孩子**的**右子树**中插入导致不平衡（LR）；
- 在A的**右孩子**的**左子树**中插入导致不平衡（RL）；

## 2. 调整最小不平衡子树（LL）
如图，使用方框代表一个抽象的子树，高度为H。经过`LL`型插入后左孩子的左子树高度变成了`H+1`。这个时候A的平衡因子由1变成2，导致了不平衡。

![[img/Ch05 树/61 LL不平衡子树.png]]

在这里使用三个抽象树都是高度H，原因是因为，这里刚好设置的高度满足，LL插入后可以立即形成一个最小不平衡树，可以举例AR的高度是`H+1`试一试即可证明。

【调整方法】**LL平衡旋转**（**右单旋转**）。
二叉排序树的特性：左子树结点值 < 根结点值 < 右子树结点值，所以：`BL<B<BR<A<AR`。
由于在结点A的左孩子（L）的左子树（L）上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。
将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。

![[img/Ch05 树/62 LL不平衡子树右旋.png]]

代码实现：
```c
// 假设A的父结点指针是gf，A的结点指针是f，B的结点指针是p。
f->lchild = p->rchild;      // 把BR变成AL
p->rchild = f;              // A成B的右子树
gf->lchild/rchild = p;      // B变成gf的子树
```

## 3. 调整最小不平衡子树（RR）
【调整方法】RR平衡旋转（左单旋转）。

![[img/Ch05 树/63 RR不平衡子树.png]]

由于在结点A的右孩子（R）的右子树（R）上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。
将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。

![[img/Ch05 树/64 RR不平衡子树左旋.png]]

代码实现：
```c
// 假设A的父结点指针是gf，A的结点指针是f，B的结点指针是p。
f->rchild = p->lchild;      // 把BL变成AR
p->rchild = f;              // A成B的右子树
gf->lchild/rchild = p;      // B变成gf的子树
```

## 4. 调整最小不平衡子树（LR）
【调整方法】**LR平衡旋转**（先左后右双旋转）。
![[img/Ch05 树/65 LR不平衡子树.png]]
由于在A的左孩子（L）的右子树（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。
1. 先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，
2. 然后再把该C结点向右上旋转提升到A结点的位置。
图中以插入结点在C的右子树CR中，等量换做到CL上依然可以按照相同方法保证调整成功。
![[img/Ch05 树/66 LR不平衡子树调整.png]]
## 4. 调整最小不平衡子树（LR）
【调整方法】**RL平衡旋转**（先右后左双旋转）。
由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先**右旋转后左旋转**。
![[img/Ch05 树/67 RL不平衡子树.png]]
1. 先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置；
2. 然后再把该C结点向左上旋转提升到A结点的位置。
图中以插入结点在C的左子树CL中，等量换做到CH上依然可以按照相同方法保证调整成功。
![[img/Ch05 树/68 RL不平衡子树调整.png]]

总结只有左孩子才能右上旋，右孩子才能左旋。每次旋转都会导致孩子成为父亲，父亲成为孩子。

在插入结点中，只要将**最小不平衡子树调整平衡**，则其他祖先结点都会恢复平衡。操作导致“最小不平衡子树”高度+1，经过调整后高度恢复。

若树高为h，则最坏情况下，查找一个关键字最多需要对比 h 次，即查找操作的时间复杂度不可能
超过 $O(h)$。
平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1。
假设以$n_h$表示深度为h的平衡树中含有的最少结点数。
则有$n_0= 0, n_1 = 1, n_2 = 2$，并且有：$$n_h = n_{h−1} + n_{h−2} + 1.$$
可以证明含有n个结点的平衡二叉树的最大深度为$O(log_2n)$，平衡二叉树的平均查找长度为$O(log_2n)$。

# [52]     哈夫曼树
结点的权：有某种现实含义的数值（如：表示结点的重要性等）。
结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积。
树的带权路径长度：树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）。
$$WPL = \sum_{i=1}^n W_i l_i$$

![[img/Ch05 树/69 哈夫曼树.png]]
在含有n个带权叶结点的二叉树中，其中**带权路径长度（WPL）最小的二叉树称为哈夫曼树**，也称**最优二叉树**。如果中下方的两个二叉树中，均属于哈夫曼树（Huffman Tree）。

## 1. 哈夫曼树构造
给定n个权值分别为$w_1, w_2,…, w_n$的结点，构造哈夫曼树的算法描述如下：
1. 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林`F`。
2. 构造一个新结点，从`F`中选取**两棵根结点权值最小**的树作为新结点的左、右子树，并且将新
结点的权值置为左、右子树上根结点的权值之和。
3. 从`F`中删除刚才选出的两棵树，同时将新得到的树加入`F`中。
4. 重复步骤（2）和（3），直至`F`中只剩下一棵树为止。
![[img/Ch05 树/70 哈夫曼树构造.png]]
特点：
1. 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大
2. 哈夫曼树的结点总数为2n − 1
3. 哈夫曼树中不存在度为1的结点。
4. 哈夫曼树并不唯一，但WPL必然相同且为最优。
![[img/Ch05 树/71 哈夫曼树构造.png]]

## 2. 哈夫曼编码
**可变长度编码**——允许对不同字符用不等长的二进制位表示。
若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。
假设，100题中有80题选C，10题选A，8题选B，2题选D，如果用0，1 编码这些信息，如果使用平均使用，所有答案的二进制长度=$80*2+10*2+8*2+2*2=200$ bit。
![[img/Ch05 树/72 哈夫曼编码.png]]
使用哈夫曼编码，即右侧的，将使用信息：$WPL= 80*1+10*2+2*3+8*3=130$bit。
有哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树。
哈夫曼编码使用的方式，降低二进制编码的数量，因此哈夫曼编码可用于数据压缩。
