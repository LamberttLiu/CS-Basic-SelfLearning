#数据结构 

# [11] 单链表的定义
## 1.单链表
逻辑结构：是一种线性表。

![](img/S02%20线性表/09%20链表.JPG)

**顺序表（顺序存储）：**
- 优点：可随机存取，存储密度高
- 缺点：要求大片连续空间，改变容量不方便
- 特点：每个结点中**只存放数据元素**
**单链表（链式存储）：**
- 优点：不要求大片连续空间，改变容量方便
- 缺点：不可随机存取，要耗费一定空间存放指针
- 特点：每个结点除了存放数据元素外，还要存储指向下一个节点的指针

![](img/S02%20线性表/10%20顺序表%20Vs%20链表.jpg)

## 2.用代码定义单链表
```c
struct LNode{
	ElemType data;
	struct LNode *next;
}
struct LNode* p = (struct LNode*) malloc(sizeof(struct LNode));
```
上面的写法比较繁琐，因此用`typedef`进行重定义：
```cpp
typedef struct LNode{           // 定义单链表节点类型
    ElemType data;              // 每个节点存放一个数据元素
    struct LNode *next;         // 指针指向下一个节点
}LNode,*LinkList;
```
以下有两种定义：其中
```c
LNode * L; 
```
声明一个指向单链表第一个节点的指针，**结构体指针**，主要强调这是一个节点。
```c
LinkList L;
```
声明一个指向单链表第一个节点的指针，**结构体指针**，主要强调这是一个单链表。
![](img/S02%20线性表/11%20链表的节点.jpg)

**二者的表示是等价的，但是后者代码可读性更强**。

## 3.初始化单链表

- 不带头节点的单链表
```cpp
typedef struct LNode{           // 定义单链表节点类型
    ElemType data;              // 每个节点存放一个数据元素
    struct LNode *next;         // 指针指向下一个节点
}LNode, *LinkList;

bool InitList(LinkList &L){
    // 防止出现脏数据
    L = NULL;                   // 空表，暂时还没有任何节点
    return true;
}

void test(){
    // 声明一个指向单链表的指针，这里的L是结构体指针
    // 注意此处并没有创建一个节点
    LinkList L;
    //初始化一个空表
    InitList(L);
    //......后续代码....
}
```

- 带头节点的单链表
```cpp
typedef struct LNode{           // 定义单链表节点类型
    ElemType data;              // 每个节点存放一个数据元素
    struct LNode *next;         // 指针指向下一个节点
}LNode, *LinkList;

// 初始化一个单链表(带头结点)
bool InitList(LinkList &L){
    // 分配头节点
    L = (LNode*) malloc(sizeof(LNode));
    // 判断是否分配成功
    if (NULL == L) {
	     return false;
    }
    // 头节点后暂时没有存放数据
    L->next = NULL;
    return true;
}

void test(){
    // 声明一个指向单链表的指针，这里的L是结构体指针
    // 注意此处并没有创建一个节点
    LinkList L;
    // 初始化一个空表
    InitList(L);
    //......后续代码....
}
```

不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理，需要用不同的代码逻辑，对空表和非空表的处理需要用不同的代码逻辑。
带头结点，写代码更方便。
![](img/S02%20线性表/12%20链表的两种表示%20是否带头结点.JPG)

# [12] 单链表的插入删除
## 1. 单链表插入
- 按照位序插入(带头结点)
`ListInsert(&L,i,e)`在表L中的第i个位置上插入了指定元素e。
```c
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode, *LinkList;

//在第i个位置插插入元素e (带头结点)
bool ListInsert(LinkList &L, int i, ElemType e){
    if(i<1)
	    return false;
	LNode *p;           // 结构体指针p, 指向当前扫描到的结点
    int j = 0;          // 当前p指向的是第j个结点
    p = L;              // L 指向头结点，头结点是第0个结点(不存数据)

    while (p != NULL && j < i-1) {      // 循环找到第 i-1 个结点
        p=p->next;
        j++;
    }

	if(p==NULL){                        // i值超过了边界，不合法
        return false;
    }
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next; 
    p->next = s;                        // 将结点s连到p之后
    return true;                        // 插入成功
}
```
时间复杂度：`O(n)`.


- 按照位序插入(不带头结点)
不存在“第0个”节点。

```c
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode, *LinkList;

bool ListInsert(LinkList &L，int i,ElemType e){
	if(i<1)
		return false;
	if(i==1){
	    LNode *s = (LNode*)malloc (sizeof(LNode));
        s->data = e;      // 给数据域赋值
        s->next = L;      // 新指针，代替指向原来的头节点的指针
        L = s;            // 用L指针指向现在的新头节点
        return true;
	}

    LNode* p;
    int j = 1;              // 当前p指向了第1个节点;
    p = L;
    while(p!=NULL && j<i-1){
        p = p->next;
        j++;
    }
    if(NULL == p)           // 循环找到第 i-1 个结点
        return false;
    LNode* s = (LNode*)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

> 结论：不带头结点写代码更不方便，推荐用带头结点

- 在某个指定节点后插元素
```c
// 在p节点后插入元素 e
bool InsertNextNode(LNode*p,ElemType e){
    if (p == NULL)
        return false;
    LNode *s = (LNode*)malloc (sizeof(LNode));
    // 判定内存是否申请成功
    if (s == NULL)
        return false;
    // 链表插入数据分三步，填数，解链，重新成链
    s -> data = e;
    s -> next = p -> next;
    p -> next = s;
    return true;
}
```

- 在某个指定节点前插元素
`InsertPriorNode(Linklist L,LNode *p,ElemType e)`循环遍历查找p的前驱，再对q后插。
该算法的时间复杂度是`O(n)`

还有另一种算法，**本质是Swap替换**
```c
bool InsertPriorNode (LNode *p, ElemType e){
    if (p == NULL)
        return false;
    LNode *s = (LNode*)malloc (sizeof(LNode));
    // 判定内存是否申请成功
    if (s == NULL)
        return false;
    // 解链，重新成链
    s -> next = p -> s;
    p -> next = s;
    // 数据交换swap
    s -> data = p -> data;
    p -> data = e;
    return true;
}
```
该算法的时间复杂度是`O(1)`.

## 2. 单链表删除
`ListDelete(&L,i,&e)`：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。
头结点可以看作“第0个”结点，找到第 i-1 个结点，将其指针指向第i+1个结点，并释放第i个结点
- 按位序删除(带头结点)
```c
bool ListDelete(Linklist &L, int i, ElemType &e){
    if(i<1)
        return false;
    LNode *p;           // 结构体指针p, 指向当前扫描到的结点
    int j = 0;          // 当前p指向的是第j个结点
    p = L;              // L 指向头结点，头结点是第0个结点(不存数据)

    while (p!=NULL && j < i-1) {      // 循环找到第 i-1 个结点
        p = p->next;
        j++;
    }

    if(p==NULL)         // i值不合法
        return false;
    if(p -> next == NULL)       // 第i-1个结点后没有其他结点
        return false;
    LNode *q = p -> next;       // 令q指向被删除结点
    e = q -> data;              // 用e把返回值带回来
    p -> next=q -> next;        // 将*q结点从链中断开
    free(q);                    // 释放结点的存储空间
    return true;                // 删除成功
}
```
该算法的时间复杂度是`O(n)`
![[11 链表删除（给定位序）.png]]
- 指定节点的删除
方法1：传入头指针，循环寻找 p 的前驱结点
方法2：偷天换日（类似于结点前插的实现）
以下以方法2为例的代码
```c
bool DeleteNode(LNode *p){
    if(p==NULL)
        return false;
    // 令q指向*p的后继结点
    LNode *q = p -> next;
    // 和后继节点交换数据域
    p -> data = p -> next -> data;
    // 将*q结点从链中断开
    p -> next = q -> next;
    free(p);
    return true;
}
```

以上的时间复杂度是`O(1)`
问题：如果p是最后一个结点…只能从表头开始依次寻找p的前驱，时间复杂度 `O(n)`

# [13]      单链表的查找
## 1. 按位查找
`GetElem(L,i)`:按位查找，获取L中的第i个为主的元素的值。

```c
LNode* GetElem(Linklist L,int i){
    if(i<0){
        return NULL;
    }
    LNode *p;
    int j = 0;
    p = L;
    while(p!=NULL && j<i){
        p = p->next;
        j++;
    }
}
```
时间复杂度 `O(n)`

## 2. 按值查找
`LocateElem(L,e)`:按值查找，在表L中查找具有给定关键字值的元素。
```c
LNode * LocateElem(LinkList L,ElemType e){
    LNode *p = L->next;
    // 从第一个结点开始查找数据域为e的结点
    while(p != NULL && p-> data != e){
        p = p->next;
    }
    return p;     //找到后返回该结点指针，否则返回NULL
}
```
时间复杂度 `O(n)`

## 3.求表的长度
```c
int Length(LinkList L){
    int len = 0;
    LNode *p = L;
    while(p->next != NULL){
        p = p->next;
        len++;
    }
    return len;
}
```

# [14]      单链表的建立
## 1. 尾插法
首先初始化一个链表：[[Ch02-2 链表#3.初始化单链表]]
然后
```text
设置变量length记录链表长度
while{
    每次取一个数据元素e;
    ListInsert(L,length+1,e)插到尾部；
    length++;
}
```

```c
bool ListInsert(LinkList &L, int i, ElemType e){
    if(i<1){
        return false;
    }    
    LNode *p;
    int j = 0;
    p = L;

    while(p != NULL && j < i-1){        // 循环找到第 i-1 个结点
        p = p->next;
        j++
    }
    if ( p== NULL){
        return false;
    }
    LNode *s =(LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;                        // 把结点s连到p之后
    return true;
}
```
以上的时间复杂度是$O(n^2)$,并不好
```c
LinkList List_TailInsert(LinkList &L){  // 正向建立单链表
    int x;                              // ElemType 整型
    L = (LinkList)malloc(sizeof(LNode));// 头节点
    LNode *s,*r=L;                      // r为表尾指针
    while(scanf("%d",&x) != EOF){
        s = (LNode*)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s; 
    }
    r->next = NULL;
    return L;
}
```

以上的时间复杂度是`O(n)`
## 2. 头插法
头插法是一个对指定节点的核心操作。具体方法：
```text
初始化单链表
while{
    每次取一个数据元素e;
    InsertNextNode(L,e);
}
```
具体实现：
```c
LinkList List_HeadInsert(LinkList &L){
    LNode *s;
    int x;
    L = (Linklist)malloc(sizeof(LNode));    //创建头节点
    L->next=NULL;
    while(scanf("%d",&x) != EOF){
        s=(LNode*)malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;
        L->next = s;
    }
    return L;
}
```

养成好习惯，只要是初始化指针，都需要先把头指针指向NULL。
尾插法，十分适用于链表的逆置。

# [15]      双链表
![[15 单链表 VS 双链表.png]]
### 1.初始化
![[16 双链表的初始化.png]]
双链表的初始化，带头结点
```c
// 声明
typedef struct DNode{
    ElemType data;
    struct DNode *prior,*next;
}DNode,*DLinklist;

// 初始化双链表
bool InitDLinklist(Dlinklist &L){
    L = (DNode*)malloc(sizeof(DNode));
    if(L == NULL){
        return false;
    }
    // 头结点的 prior 永远指向 NULL
    L->prior = NULL;
    L->next = NULL;
    return true;
}

void testDLinkList(){
    DLinkList L;
    InitDLinkList (L);
    /* 后续代码 */
}
```

如何对一个双链表判空？
```c
bool Empty(DLinkList L){
    if (L->next == NULL){
        return true;
    }
    else{
        return false;
    }
}
```
### 2.插入
插入时需要考虑其后是否有后继节点，如果没有后继节点，会容易产生问题

```c
// 在p结点后插入s结点
bool InsertNextDNode(DNode *p,DNode *s){
    // 非法参数
    if (p == NULL || s == NULL){
        return false;
    }
    // 注意以下四个步骤的顺序
    s->next = p->next;
    // 如果p结点后有后继结点
    if (p->next != NULL){
        p->next-prior = s;
    }
    s->prior = p;
    p->next = s;
    return true;
}
```
`InsertNextDNode(DNode *p,DNode *s)`是函数原型，按位序插入和前插操作都是它的变式。
1. 按位序插入，以头结点开始i，找到一个位置的前驱节点，对前驱结点进行后插操作；
2. 前插操作，对这个结点的前一位，进行后插操作。

### 3.删除

```c
// 删除p的后继节点q
bool DeleteNextDNode(DNode *p){
    // 判空
    if (p == NULL){
        return false;
    }
    // 找到p的后继结点q，如果判空表示没有后继节点，删除失败
    DNode *q = p->next;
    if (q == NULL){
        return false;
    }
    p->next = q-next;
    // 判断q结点是否最后一个结点
    if (q->next != NULL){
        q->next->prior = p;
    }
    free(p);
    return true;
}
```

如何销毁双链表？ 使用while循环，对头结点后的每个结点进行删除。
```c
void DestroyList(DLinkList &L){
    // 循环释放各个数据结点
    while(L->next != NULL)
    {
        DeleteNextNode(L);
    }
    free(L);        // 释放头指针
    L = NULL;       // 头指针指向NULL
}
```
### 4.遍历
双链表指针有前向遍历和后向遍历
```c
// 后向遍历
while(p != NULL){
    p = p->next;
    /*对结点进行处理，例如打印，取值等*/
}
```

```c
// 前向遍历
while(p != NULL){
    p = p->prior;
    /*对结点进行处理，例如打印，取值等*/
}
```
如果不针对头结点
```c
// 前向遍历,跳过头结点
while(p->prior != NULL){
    p = p->prior;
    /*对结点进行处理，例如打印，取值等*/
}
```
双链表不可随机存取，按位查找、按值查找操作都只能用遍历的方式实现。时间复杂度`O(n)`

# [16] 循环链表
循环链表分循环单链表和循环双链表

## 1. 循环单链表
单链表：表尾结点的next指针指向 NULL
循环单链表：表尾结点的next指针指向头结点
```c
typedef struct LNode{           // 定义单链表节点类型
    ElemType data;              // 每个节点存放一个数据元素
    struct LNode *next;         // 指针指向下一个节点
}LNode,*LinkList;

// 初始化一个循环单链表
bool InitList(LinkList &L){
    // 分配头节点
    L = (LNode*) malloc(sizeof(LNode));
    // 判断是否分配成功
    if (NULL == L){
        return false;
    }
    // 头节点next指向头结点自身
    L->next = L;
    return true;
}
```

如何判断结点是否为循环单链表的表尾
```c
bool isTail(LinkList L, LNode *p){
    if (p->next == L){
        return true;
    }
    else{
        return false;
    }
}
```
- 单链表：从一个结点出发，只能找到后续的各个结点
- 循环单链表：从一个结点出发，可以找到其他任何一个结点

## 2. 循环双链表
- 双链表：表头结点的 prior 指向 NULL；表尾结点的 next 指向 NULL
- 循环双链表：表头结点的 prior 指向表尾结点；表尾结点的 next 指向头结点
```c
// 声明
typedef struct DNode{
    ElemType data;
    struct DNode *prior,*next;
}DNode,*DLinklist;

// 初始化空的双链表
bool InitDLinklist(Dlinklist &L){
    L = (DNode*)malloc(sizeof(DNode));
    if(L == NULL){
        return false;
    }
    
    L->prior = L;       // 头结点的 prior 指向头结点
    L->next = L;        // 头结点的 next 指向头结点
    return true;
}

void testDLinkList(){
    DLinkList L;
    InitDLinkList (L);
    /* 后续代码 */
}
```

如何对一个双链表判空？
```c
// 双链表判空
bool Empty(DLinkList L){
    if (L->next == L){
        return true;
    }
    else{
        return false;
    }
}
```

如何判断结点是否为循环双链表的表尾
```c
// 双链表判尾结点
bool isTail(DLinkList L, DNode *p){
    if (p->next == L){
        return true;
    }
    else{
        return false;
    }
}
```

```c
// 双链表的插入，在p结点后插入s结点
bool InsertNextDNode(){
    s->next = p->next;  // 把结点*s 插到结点*p 后面
    p->next->prior = s;  // 这句不需要条件判定了
    s->prior = p;
    p->next = s;
    return true;
}
```

```c
// 双链表的删除，删除p结点后插入q结点
p->next = q-next;
q->next->prior = p;
free(p);
```

# [17] 静态链表
## 1. 静态链表与单链表的区别
- 单链表：各个结点在内存中星罗棋布、散落天涯。
- 静态链表：分配一整片连续的内存空间，各个结点集中安置。
  每个结点包含**数据元素**和**下一个结点的数组下标**(游标)
  每个数据元素 4B，每个游标 4B（每个结点共 8B）。
  设起始地址为 addr，e1 的存放地址为 addr + 8*2

## 2. 代码实现
```c
// 声明
#define MaxSize 10          // 静态链表最大长度
typedef struct {            // 静态链表结构类型定义
    ElemType data;          // 存储数据元素
    int next;               // 下一个元素的数组下标
}SLinkList[MaxSize];        // 静态链表

// 初始化
void testSlinkList(){
// a是一个静态链表,本质是一个结构体数组,sizeof(a)=80;
    SLinkList a;            
    /* 后续代码 */
}
```

- 静态链表实际上使用数组方式实现的链表
优点： 增删 操作不需要大量移动元素
缺点： 不能随机存取，只能从头结点开始依次往后查找，容量固定不可变

- 适用场景：
1. 不知处指针的低级语言；
2. 数据元素数量固定不变的场景（如操作系统 文件分配表FAT）

# [18] 顺序表和链表的比较
## 1. 逻辑结构
都属于线性表，都是线性结构

## 2. 存储结构
1. 顺序表
   优点：支持随机存取、存储密度高
   缺点：大片连续空间分配不方便，改变容量不方便

2. 线性表
   优点：离散的小空间分配方便，改变容量方便
   缺点：不可随机存取，存储密度低

## 3. 基本操作 -- 创销 增删改查
1. 创
- 顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源
	静态分配：静态数组；容量不可改变；
	动态分配：动态数组（`malloc()`、`free()`）；容量可改变，但需要移动大量元素，时间代价高。
- 链表：只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展

2. 销
- 顺序表：修改 Length = 0
	静态分配：静态数组 系统自动回收空间
	动态分配：动态数组（malloc、free），需要手动 free
- 链表：依次删除各个结点（free）

3. 增删
- 顺序表：插入/删除元素要将后续元素都后移/前移，时间复杂度 `O(n)`，时间开销主要来自移动元素，
  若数据元素很大，则移动的时间代价很高
- 链表：插入/删除元素只需修改指针即可，时间复杂度 `O(n)`，时间开销主要来自查找目标元素，查找元素的时间代价更低

4. 查
- 顺序表：按位查找：`O(1)`，按值查找：`O(n)`
	若表内元素有序，可在$O(\log_{2}{n})$ 时间内找到
- 链表：按位查找：`O(n)`，按值查找：`O(n)`

>总结：
>表长难以预估、经常要增加/删除元素 ——链表
>表长可预估、查询（搜索）操作较多 ——顺序表


