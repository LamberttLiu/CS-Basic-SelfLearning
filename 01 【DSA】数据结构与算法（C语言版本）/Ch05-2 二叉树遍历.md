#数据结构 
# [41]     二叉树的存储结构
## 1. 顺序存储
```c
#define MaxSize 100
typedef struct {
    Element value;     // 结点中的数据元素
    bool isEmpty;    // 结点是否为空
} TreeNode;

TreeNode t[MaxSize];
```
定义一个长度为 `MaxSize` 的数组 t ，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点。
```c
// 初始化时所有结点标记为空
for (int i = 0; i < MaxSize; i++) {
    t[i].isEmpty = true;
}
```
![[img/Ch05 树/17 完全二叉树顺序存储.png]]
让第一个位置空缺，保证数组下标和结点编号一致。

 在**完全二叉树**中：
- i 的左孩子是 2i
- i 的右孩子是 2i + 1；
- i 的父节点 $⌊i / 2⌋$
- i 所在的层次：$⌈\log_{2}{(n+1)}⌉$ 或者 $⌊\log_{2}{(n+1)}⌋$

| 判断场景            | 条件      |
| ------------------- | --------- |
| 判断i是否有左孩子？ | $2*i ≤ n$ |
| 判断i是否有右孩子？ | $2*i + 1 ≤ n$|
| 判断i是否是叶子/ 分支结点？| $i> ⌊n/2⌋$|

![[img/Ch05 树/18 不完全二叉树顺序存储.png]]
二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来。

最坏情况：高度为 h 且只有 h 个结点的单支树（所有结点只有右孩子），也至少需要 $2^h-1$ 个存储单元。
![[img/Ch05 树/19 最坏情况的二叉树顺序存储.png]]

## 2. 链式存储
```c
typedef struct BiTNode {
    ElemType data;
    struct BiTNode *lchild, *rchild;  // 左右孩子指针
} BiTNode, *BiTree;
```
`n` 个结点的二叉链表共有 `n+1` 个空链域。
实际举例：
```c
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 定义一个空树
BiTree root = NULL;

// 插入根节点
root = (BiTree)malloc(sizeof(BiTNode));
root->data = 1;
root->lchild = NULL;
root->rchild = NULL;

// 插入新节点
BiTNode *p = (BiTNode*) malloc(sizeof(BiTNode));
p->data = 2;
p->lchild = NULL;
p->rchild = NULL;
root->lchild = p; // 作为根节点的左孩子
```
对于这样的二叉链表而言，找对应结点的子节点相对容易，而对于给定结点的父节点，相对较难。只能通过从头结点开始遍历查找。

```c
typedef struct BiTNode {
    ElemType data;                
    struct BiTNode *lchild, *rchild;    // 左、右孩子指针
    struct BiTNode *parent;                // 父节点指针
} BiTNode, *BiTree;                     // 三叉链表，方便找父节点
```

![[img/Ch05 树/20 二叉树链式存储.png]]

# [42]     二叉树的先中后序遍历
遍历：按照某种次序把所有结点都访问一遍。
- 层次遍历：基于树的层次特性确定的次序规则
- 前/ 中 / 后序遍历：基于树的递归特性确定的次序规则。
![[img/Ch05 树/21 二叉树遍历.png]]
- **先序遍历**：根-->左-->右（NLR）；
- **中序遍历**：左-->根-->右（LNR）；
- **后序遍历**：左-->右-->根（LRN）。

![[img/Ch05 树/22 三种遍历.png]]

## 1. 前序遍历
前序遍历（PreOrder）的操作过程如下：
1. 若二叉树为空，则什么也不做；
2. 若二叉树非空：
    1. **访问根结点**；
    2. 先序遍历左子树；
    3. 先序遍历右子树。

```c
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 先序遍历
void PreOrder(BiTree T) {
    if (T != NULL) {
        visit(T);                // 访问根节点
        PreOrder(T->lchild);    // 递归遍历左子树
        PreOrder(T->rchild);    // 递归遍历右子树
    }
}
```

![[img/Ch05 树/23 前序遍历.png]]

## 2. 中序遍历
中序遍历（InOrder）的操作过程如下：
1. 若二叉树为空，则什么也不做；
2. 若二叉树非空：
    1. 中序遍历左子树；
    2. **访问根结点**；
    3. 中序遍历右子树。

```c
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 中序遍历
void InOrder(BiTree T) {
    if (T != NULL) {
        InOrder(T->lchild);    // 递归遍历左子树
        visit(T);            // 访问根节点
        InOrder(T->rchild);    // 递归遍历右子树
    }
}
```

![[img/Ch05 树/24 中序遍历.png]]
## 3. 后序遍历
后序遍历（PostOrder）的操作过程如下：
1. 若二叉树为空，则什么也不做；
2. 若二叉树非空：
    1. 后序遍历左子树；
    2. 后序遍历右子树。
    3. **访问根结点**；

```c
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 中序遍历
void PostOrder(BiTree T) {
    if (T != NULL) {
        PostOrder(T->lchild);    // 递归遍历左子树
        PostOrder(T->rchild);    // 递归遍历右子树
        visit(T);                // 访问根节点
    }
}
```

![[img/Ch05 树/25 后序遍历.png]]
前、中、后序遍历皆属于「**深度优先遍历** Depth-First Traversal」，其体现着一种“先走到尽头，再回头继续”的回溯遍历方式。

## 4. 遍历算法的应用举例
求树的深度
```c
int treeDepth(BiTree T){
    if(T == NULL){
        return 0;
    } else {
        int l = treeDepth(T->lchild);
        int r = treeDepth(T->rchild);
        // 树的深度是左子树深度和右子树的深度的最大值
        // 典型后续遍历
        return l > s ? (l + 1) : (s + 1);
    }
}
```

# [43]     二叉树的层序遍历
**算法**：
1. 初始化一个辅助队列
2. 根结点入队
3. 若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）
4. 重复第3步直至队列为空

![[img/Ch05 树/26 层序遍历.png]]
![[img/Ch05 树/27 层序遍历.png]]
层序遍历本质上是「**广度优先搜索** Breadth-First Traversal」，其体现着一种“一圈一圈向外”的层进遍历方式。

```c
// 二叉树节点 链式存储
typedef struct BiTNode {
    char data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 链式队列节点
typedef struct LinkNode {
    BiTNode *data;        // 存指针而非节点
    struct LinkNode *next;
} LinkNode;

typedef struct {
    LinkNode *front, *rear;    // 队头队尾
} LinkQueue;

// 层序遍历
void LevelOrder(BiTree T) {
    LinkQueue Q;
    InitQueue Q;    // 初始化辅助队列
    BiTree p;
    EnQueue(Q,T);   // 根节点入队
    while(!IsEmpty(Q)){        // 队列不空则循环
        DeQueue(Q, p);        // 队列结点出队
        visit(p);
        if(p->lchild != NULL)
            EnQueue(Q, p->lchild);    // 左孩子入队
        if(p->rchild != NULL)
            EnQueue(Q, p->rchild);    // 右孩子入队
    }
}
```

# [44]     由遍历序列构造二叉树
## 1. 不同二叉树的遍历序列
**中序遍历**：递归遍历左子树 ---> 根结点 ---> 递归遍历右子树。

> 对于一个中序遍历序列，可能对应多种二叉树形态

![[img/Ch05 树/28 中序遍历排列.png]]

**前序遍历**：根结点 ---> 递归遍历左子树 ---> 递归遍历右子树

> 对于一个前序遍历序列，可能对应多种二叉树形态

![[img/Ch05 树/29 前序遍历排列.png]]

**后序遍历**：递归遍历左子树 ---> 递归遍历右子树 ---> 根结点

> 一个后序遍历序列，可能对应多种二叉树形态。

![[img/Ch05 树/30 后序遍历排列.png]]
**层序遍历**：

> 一个层序遍历序列，可能对应多种二叉树形态。

![[img/Ch05 树/31 层序遍历排列.png]]


> **结论：若只给出一棵二叉树的 前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树**。但是给出中序 + X 两种，就可以根据遍历序列构造唯一的二叉树。

## 2. 前序 + 中序遍历序列
-   **前序遍历**：根结点   →   前序遍历左子树   →   前序遍历右子树
-   **中序遍历**：中序遍历左子树    →    根结点     →     中序遍历右子树

![[img/Ch05 树/32 前序+中序.png]]
【例子】给出前序遍历`ADBCE`，中序遍历`BDCAE`，求出二叉树的结构。

![[img/Ch05 树/33 前序+中序.png]]

## 3. 后序 + 中序遍历序列
-   **后序遍历**：后序遍历左子树   →   后序遍历右子树   →  根结点
-   **中序遍历**：中序遍历左子树    →    根结点     →     中序遍历右子树

![[img/Ch05 树/34 后序+中序.png]]
【例子】给出后序遍历`EFAHCIGBD`，中序遍历`EAFDHCBGI`，求出二叉树的结构。
![[img/Ch05 树/35 后序+中序.png]]

## 4. 层序 + 中序遍历序列
-   **层序遍历**：根结点     →     左子树的根     →     右子树的跟
-   **中序遍历**：中序遍历左子树    →    根结点     →     中序遍历右子树

![[img/Ch05 树/36 层序+中序.png]]

【例子】给出层序遍历`DABEFCGHI`，中序遍历`EAFDHCBGI`，求出二叉树的结构。
![[img/Ch05 树/37 层序+中序.png]]
由二叉树遍历序列构造二叉树，通常有三种方式：
1. 前序 + 中序 遍历序列；
2. 后序+ 中序 遍历序列；
3. 层序 + 中序 遍历序列。

其中关键的做法是：**找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点**。
![[img/Ch05 树/38 二叉树遍历序列构造二叉树.png]]
而前序、后序、层序序列的两两组合无法唯一确定一个二叉树。
