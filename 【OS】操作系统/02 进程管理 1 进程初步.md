# 02 进程管理
#操作系统 
## [9] 进程的概念、组成、特征
**程序：是静态的**，就是个存放在磁盘里的可执行文件，如：QQ.exe。
**进程：是动态的**，是程序的一次执行过程，如：可同时启动多次QQ程序，同一个程序多次执行会对应多个进程。

思考：操作系统是这些进程的管理者，它要怎么**区分各个进程**？
当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—— **PID（Process ID，进程ID）**。
操作系统要记录PID、进程所属用户ID（UID），还要记录给进程**分配了哪些资源**（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件），还要记录**进程的运行情况**（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）。

### 1. 进程的组成 - PCB
这些信息都被保存在一个**数据结构**PCB （Process Control Block）中，即**进程控制块**。操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。
`Linux`系统中的PCB叫做`task struct`。
![[01 PCB作用.png]]
PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。
操作系统对进程进行管理工作所需的信息都存在PCB中。
### 2. 进程的组成 - 程序段、数据段
![[02 进程组成.png]]
PCB 是给操作系统用的。程序段、数据段是给进程自己用的。
![[03 进程运行过程.png]]
一个**进程实体**（进程映像）由PCB、程序段、数据段组成。进程是动态的，进程实体（进程映像）是静态的。
可以理解成，**进程实体**（进程映像）是某一种状态下进程动态的快照。
### ★ 进程与进程实体
程序段、数据段、PCB三部分组成了**进程实体**（进程映像）
引入进程实体的概念后，可把进程定义为：进程是**进程实体的运行过程**，是系统进行**资源分配和调度**的一个独立单位。
- 同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的（都是运行着相同的QQ程序）。
- 程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关。
- 一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行。

### 3. 进程的特点
程序是静态的，进程是动态的，相比于程序，进程拥有以下特征:
![[04 进程特点.png]]
## [10]进程的状态与转换、进程的组织

### 1. 进程状态
- 进程正在被创建时，它的状态是“**新建态**”，在这个阶段操作系统会为进程分配资源、初始化PCB。
- 当进程创建完成后，便进入“**就绪态**”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行。
- 如果一个进程此时在CPU上运行，那么这个进程处于“**运行态**”，CPU会执行该进程对应的程序（执行指令序列）
- 在进程运行的过程中，可能会请求**等待某个事件的发生**（如等待某种系统资源的分配，或者等待其他进程的响应）。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“**阻塞态**”。当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行。
- 一个进程可以执行 exit 系统调用，**请求操作系统终止该进程**。此时该进程会进入“**终止态**”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要**回收该进程的PCB**。当终止进程的工作完成之后，这个进程就彻底消失了。
![[05 进程状态.png]]
运行、就绪、阻塞，是三个基本状态。进程的整个生命周期中，大部分时间都处于三种基本状态。
单CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态。

进程PCB中，会有一个变量 state 来表示进程的当前状态。
如：1表示创建态、2表示就绪态、3表示运行态…
为了对**同一个状态下**的各个进程进行**统一的管理**，操作系统会将各个进程的PCB组织起来。

### 2. 进程组织
![[06 进程组织方式.png]]
按照进程状态将PCB分为多个队列，操作系统持有各个队列的指针：
![[07 进程链接.png]]
总体上来说，进程的链接方式经常使用，而索引方式运用较少。
![[08 进程索引.png]]
## [11]进程控制
进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现
进程状态转换等功能。总之，进程控制就是要实现进程状态转换。
![[09 进程控制 原语.png]]
进程控制通过“原语”实现。
原语是一种特殊的程序，它的执行具有原子性。也就是说，这段程序的运行必须一气呵成，不可中断。

### 1. 控制过程
问题：为什么原语不可以中断呢？
假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态。
假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：
1. 将PCB2的 state 设为 1。
2. 将PCB2从阻塞队列放到就绪队列。
![[10 进程控制.png]]
### 2. 开中断与关中断
原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。可以用 “**关中断指令**”和“**开中断指令**”这两个**特权指令**实现原子性。
![[11 通常情形下的中断处理.png]]正常情况：CPU每执行完一条指令都会**例行检查**是否有**中断信号**需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。
![[12 关中断和开中断.png]]
CPU执行了关中断指令之后，就**不再例行检查中断信号**，直到执行开中断指令之后才会恢复检查。
这样，关中断、开中断 之间的这些指令序列就是不可被中断的，这就实现了“原子性”。
★ 开中断和关中断的程序，都在**内核态**运行，绝不可能允许用户程序使用。

### 3. 进程控制相关的原语
关于相关的原语包含**进程的创建、进程中止、进程阻塞、进程唤醒、进程切换**。
1. 创建原语
![[13 进程创建.png]]
2. 进程的终止
![[14 进程终止.png]]
3. 进程的阻塞和唤醒
![[15 唤醒原语.png]]
4. 进程的切换
![[16 进程切换.png]]
### 4.  进程运行的深入研究
对程序的运行从CPU角度，进行剖析：在CPU处理器当中，有以下4个常用的寄存器，用于存储程序运行过程中的中间变量。
![[17 CPU寄存器.png]]
- 问题：如果执行完指令3后，另一个进程开始上CPU运行。另一个进程在运行过程中也会使用各个寄存器，之后还怎么切换回之前的进程？数据等如果被覆盖怎么解决？
- 解决办法：在进程切换时先在PCB中保存这个进程的运行环境（保存一些必要的寄存器信息）。

总结，无论哪个进程控制原语，要做的无非三类事情：
1. 更新PCB中的信息
2. 将PCB插入合适的队列
3. 分配/回收资源

## [12]进程间通信
进程间通信（Inter-Process Communication， IPC）是指两个进程之间产生数据交互。
例如将微博的内容转发到微信，就是一种典型的进程间通信。
![[18 IPC举例.png]]
进程是**分配系统资源**的单位（包括内存地址空间），因此各进程拥有的**内存地址空间相互独立**。
### 1. 共享存储
为了保证安全，一个进程不能直接访问另一进程的地址空间。
![[19 共享存储区.png]]
为避免出错，各个进程对共享空间的访问应该是互斥的。各个进程可使用操作系统内核提
供的同步互斥工具（如P、V操作）。
注：通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中（后文内存管理内容）。
以Linux系统为例
```c
// Linux 中，如何实现共享内存：
int shm_open(……); //通过 shm_open 系统调用，申请一片共享内存区
void* mmap (……); //通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间
```
共享存储的方式有两类，一种是基于数据结构的共享，还有一类是基于存储区的共享。
-  基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种**低级通信方式**;
-  基于存储区的共享：操作系统在内存中划出一块共享存储区，对于数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式内存速度很快，是一种**高级通信方式**。

### 2. 消息传递
进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“**发送消息/接收消息**”两个原语进行数据交换。
消息传递分为**直接通信传递**和**间接通信方式**。
1. **直接通信传递**
![[20 直接通信方式.png]]
发送进程消息，利用OS所提供的发送原语，直接把消息发给目标进程。
2. **间接通信方式**
![[21 间接通信方式.png]]
发送和接收进程都通过共享实体（邮箱）的方式进行消息的发送和接收。
可以多个进程往同一个信箱send消息，也可以多个进程从同一个信箱中receive消息。

### 3. 管道通信
“管道”是一个特殊的共享文件，又名pipe文件。其实就是在**内存**中开辟一个**大小固定的内存缓冲区**。
![[22 管道.png]]
管道和共享存储的区别：
两者都属于在内存中分配了内存缓冲区，对于管道而言，必须符合“**先进先出**”的读写顺序，是一种数据流的形式，类似“队列”数据结构，对于共享数据区而言，其读写空间相对自由。

★管道的特点
1. 管道只能采用半双工通信，某一时间段内只能实现**单向的传输**。
      如果要实现**双向同时通信**，则需要设置**两个管道**。
2. 各进程要互斥地访问管道（由操作系统实现）
3. 当管道**写满**时（大小固定决定的），写进程将**阻塞**，直到读进程将管道中的数据取走，即可**唤醒**写进程。
4. 当管道**读空**时，读进程将**阻塞**，直到写进程往管道中写入数据，即可**唤醒**读进程。
5. 管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：
     1. 一个管道允许多个写进程，一个读进程（System File系统）；
     2. 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 系统方案）。

对于管道写满或者写空的状态：写进程往管道写数据，即便管道没被写满，**只要管道没空，读进程就可以从管道读数据**；读进程从管道读数据，即便管道没被读空，**只要管道没满，写进程就可以往管道写数据**。

## [13]线程的概念
还没引入进程之前，系统中各个程序只能串行执行。对于微信来说，此进程可以同时提供音乐、文字聊天、文件传输几种操作，由于进程是程序的一次执行。但这些功能显然不可能是由一个程序顺序处理就能实现的。
传统的进程只能串行地执行一系列程序。因此，为了解决这一问题，引入了“线程”，来增加**并发度**。
![[23 线程引入.png]]
引入线程后，**线程成为了程序执行流**的最小单位，也是**基本的CPU执行单元**。

### 1. 线程与进程对比
1. **基本单位**
    1. 传统进程机制中，进程是资源分配、调度的基本单位
    2. 引入线程后，线程是**资源分配的基本单位**，**是调度基本单位**。进程只作为**除CPU之外的系统资源的分配单元**（如打印机、内存地址空间等都是分配给进程的）。 
2. **并发性**
    1. 传统机制中，进程间相互并发
    2. 引入线程之后，不仅是**进程之间可以并发**，进程内的**各线程之间也可以并发**，从而**进一步提升了系统的并发度**，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）
3. **系统开销**
    1. 传统进程间并发，需要切换进程之间运行环境，系统开销较大
    2. 线程间并发，如果是同一个同一个进程之间的线程并发，不需要切换进程环境，系统的开销小
    3. 引入线程后，并发带来的系统开销变小

举例说明：去图书馆看书。
桌子 ------> 处理机，人 ------> 进程，看不同的书 ------> 线程
- **切换进程运行环境**：有一个不认识的人要用桌子，你需要你的书收走，他把自己的书放到桌上。
- **同一进程内的线程切换**：你的舍友要用这张书桌，可以不把桌子上的书收走。
![[24 比喻.png]]

### 2. 线程的属性
- 线程是**处理机调度**的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有**就绪**、**阻塞**、**运行**三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间**共享进程的资源**
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小；切换进程，系统开销较大

## [14]线程的实现方式和多线程模型
### ★ 线程实现的关键问题
1. 线程的管理工作由谁来完成？
2. 线程切换是否需要CPU变态？
3. 操作系统是否能意识到用户级线程的存在？
4. 这种线程的实现方式有什么优点和缺点？
### 1. 用户级线程（User-Level Thread, ULT）
**历史背景**：早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的。
![[25 线程同步.png]]
拿“微信”聊天举例子，需要同步进行视频聊天、文字聊天、文件传输三个过程。
![[26 线程库调度.png]]
从代码的角度看，**线程其实就是一段代码逻辑**。上述三段代码逻辑上可以看作三个“线程”。while 循环就是一个最弱智的“线程库”，线程库完成了对线程的管理工作（如调度）。
很多编程语言提供了强大的线程库，可以实现线程的**创建、销毁、调度**等功能。
上述过程中，对于操作系统，只看得到进程，在处理机上运行的是程序员通过线程库实现的逻辑上的线程。
![[27 ULT.png]]
★ **用户级线程特点**
1. 用户级线程由**应用程序通过线程库**实现，所有的线程管理工作都由**应用程序负责**（包括线程切换）
2. 用户级线程中，**线程切换**可以在**用户态**下即可完成，无需操作系统干预。
3. 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是从**用户视角看能看到的线程**
4. 优缺点：
    1. 优点：用户级线程的切换在**用户空间**即可完成，**不需要切换到核心态**，线程管理的**系统开销小**，效率高。
    2. 缺点：当一个**用户级线程被阻塞**后，整个**进程都会被阻**塞，**并发度不高**。
5. 多个线程不可在多核处理机上并行运行，只能在**同一个处理机上运行**。

### 2. 内核级线程（Kernel-Level Thread, KLT,  又称“内核支持的线程”）
大多数现代操作系统都实现了内核级线程，如Windows、Linux。实现了由操作系统支持的线程。
![[28 KLT.png]]
1. 内核级线程的管理工作由**操作系统内核**完成。
2. 线程**调度**、**切换**等工作都由**内核负责**，因此内核级线程的切换必然需要**在核心态**下才能完成。
3. 操作系统会为每个内核级线程建立**相应的TCB**（Thread Control Block，线程控制块），通过**TCB对线程进行管理**。“内核级线程”就是“**从操作系统**内核视角看能看到的线程”
4. 优缺点
    1. 优点：当一个线程被阻塞后，别的线程还可以继续执行，**并发能力强**。多线程可在多核处理机上并行执行。
    2. 缺点：一个用户**进程**会占用**多个内核级线程**，线程切换由操作系统内核完成，需要切换到核心态，因此**线程管理的成本高**，开销大。

### 3. 多线程模型
在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种**多线程模型**。
1. **一对一模型**
一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
![[29 一对一.png]]
2. **多对一模型**：
多个用户级线程映射到一个内核级线程。且**一个进程只被分配一个内核级线程**。
优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
![[30 多对一线程.png]]
★重点：
操作系统只“看得见”**内核级线程**，因此只有内核级线程才是**处理机分配**的单位。

3. **多对多模型**
$n$ 个用户及线程映射到 $m$ 个内核级线程（$n ≥m$）。每个用户进程对应 m 个内核级线程。
克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用线程库户进程占用太多内核级线程，开销太大的缺点。获得了以上两者的优点。
![[31 多对多.png]]
> **用户级线程是“代码逻辑”的载体；内核级线程是“运行机会”的载体**。

内核级线程才是处理机分配的单位。例如：多核CPU环境下，左边这个进程最多能被分配两个核。
一段“代码逻辑”只有获得了“运行机会”才能被CPU执行。
**内核级线程**中可以**运行**任意一个有映射关系的**用户级线程代码**，**只有两个内核级线程**中正在运行的代码逻辑**都阻塞**时，这个**进程才会阻塞**。


